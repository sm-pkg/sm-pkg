use lazy_static::lazy_static;
use regex::Regex;
use serde::{Deserialize, Serialize};
use std::{
    collections::HashMap,
    io::{self, BufRead, Read},
    path,
};

type ConfigValues = HashMap<String, String>;

#[derive(Serialize, Deserialize)]
enum Format {
    CFG,
    KV,
}

#[derive(Serialize, Deserialize)]
pub struct FileConfig {
    format: Format,
    path: path::PathBuf,
}

pub fn render_cfg(mut writer: impl io::Write, values: ConfigValues) {
    for (key, value) in values {
        writeln!(writer, "{} = {}", key, value).unwrap();
    }
}

pub fn render_kv(_writer: impl io::Write) {}

pub fn create_sourcemod_cfg(overrides: &ConfigValues) -> ConfigValues {
    let mut hm: ConfigValues = HashMap::new();
    hm.insert("sm_show_activity".to_string(), "13".to_string());
    hm.insert("sm_menu_sounds".to_string(), "1".to_string());
    hm.insert("sm_vote_delay".to_string(), "30".to_string());
    hm.insert(
        "sm_datetime_format".to_string(),
        "%m/%d/%Y - %H:%M:%S".to_string(),
    );
    hm.insert("sm_immunity_mode".to_string(), "1".to_string());
    hm.insert("sm_time_adjustment".to_string(), "0".to_string());
    hm.insert("sm_flood_time".to_string(), "0.75".to_string());
    hm.insert("sm_reserve_type".to_string(), "0".to_string());
    hm.insert("sm_reserve_slots".to_string(), "0".to_string());
    hm.insert("sm_hide_slots".to_string(), "0".to_string());
    hm.insert("sm_chat_mode".to_string(), "1".to_string());
    hm.insert("sm_timeleft_interval".to_string(), "0".to_string());
    hm.insert("sm_trigger_show".to_string(), "0".to_string());
    hm.insert("sm_vote_progress_hintbox".to_string(), "0".to_string());
    hm.insert("sm_vote_progress_chat".to_string(), "0".to_string());
    hm.insert("sm_vote_progress_console".to_string(), "0".to_string());
    hm.insert(
        "sm_vote_progress_client_console".to_string(),
        "0".to_string(),
    );

    for (key, value) in overrides {
        hm.insert(key.clone(), value.clone());
    }

    return hm;
}

fn read_config<T: Read>(
    format: Format,
    reader: T,
) -> Result<HashMap<String, String>, Box<dyn std::error::Error>> {
    match format {
        Format::CFG => read_config_cfg(reader),
        Format::KV => read_config_kv(reader),
    }
}

fn read_config_cfg<T: Read>(
    reader: T,
) -> Result<HashMap<String, String>, Box<dyn std::error::Error>> {
    let mut results: HashMap<String, String> = HashMap::new();
    let buf_reader = io::BufReader::new(reader).lines();
    for line in buf_reader.map_while(Result::ok) {
        let values = match extract_pair(&line) {
            None => continue,
            Some(v) => v,
        };
        println!("{}", line);
        println!("{:?}", values);
        results.insert(values.0, values.1);
    }
    // let txt = reader.read_to_end(&buf);
    // for line in fs::read_to_string(filename).unwrap().lines() {
    //     result.push(line.to_string())
    // }

    Ok(results)
}

fn read_config_kv<T: Read>(
    _reader: T,
) -> Result<HashMap<String, String>, Box<dyn std::error::Error>> {
    let hm = HashMap::new();
    Ok(hm)
}

fn extract_pair(input: &str) -> Option<(String, String)> {
    lazy_static! {
        static ref RE: Regex = Regex::new(r#"^(\w+)\s+?\"?(.+?)\"?$"#).unwrap();
    }
    RE.captures(input).and_then(|captures| {
        let key = captures.get(1).map(|v| v.as_str())?.to_string();
        let value = captures.get(2).map(|v| v.as_str())?.to_string();
        Some((key, value))
    })
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_read_config() -> Result<(), Box<dyn std::error::Error>> {
        let results = read_config(Format::CFG, TEST_CFG_INI)?;
        assert_eq!(2, results.len());
        Ok(())
    }

    #[test]
    fn test_render_cfg() {
        let mut values = HashMap::new();
        values.insert("key1".to_string(), "\"value1\"".to_string());
        values.insert("key2".to_string(), "\"value2\"".to_string());

        let mut output = Vec::new();
        render_cfg(&mut output, values);

        assert_eq!(
            String::from_utf8(output).unwrap(),
            "key1 = \"value1\"\nkey2 = \"value2\"\n"
        );
    }

    const TEST_CFG_INI: &[u8] = br#"
// This file was auto-generated by SourceMod (v1.10.0.6488)
// quoted
sm_first_value "19"

// unquoted
sm_second_value 10.0
"#;

    const test_cfg_kv: &[u8] = br#"
"Databases"
{
    "storage-local"
    {
        "driver"            "sqlite"
        "database"            "sourcemod-local"
    }

    "clientprefs"
    {
        "driver"            "pgsql"
        "host"                "1.2.3.4"
        "database"            "clientprefs"
        "user"                "sourcemod"
        "pass"                "sourcemod"
        // "timeout"            "0"
        "port"            "5432"
    }
}
"#;
}
